# ECSpresso

*(pronounced "ex-presso")*

__Note: This is a VERY early work in progress. The documention is being autogenerated while this ECSpresso being iterated on.__

A lightweight, type-safe Entity Component System (ECS) library for TypeScript applications and games.

## Overview

ECSpresso is a flexible and efficient Entity Component System implementation that provides:

- **Type-safe API**: Fully leverages TypeScript's type system for component, event, and resource definitions
- **Event System**: Built-in pub/sub event system for communication between systems
- **Resource Management**: Global state management through a dedicated resource manager
- **Bundle System**: Modular and reusable collections of components, resources, and systems
- **Query System**: Efficient entity filtering based on component presence/absence

## Core Concepts

### Entity Component System

The ECS pattern separates data (Components) from behavior (Systems) through Entities:

- **Entities**: Unique identifiers that components can be attached to
- **Components**: Plain data objects that hold state but no behavior
- **Systems**: Logic that processes entities with specific components
- **Resources**: Global state shared between systems
- **Events**: Messages passed between systems

### Key Features

- Type-safe queries to filter entities based on component combinations
- Fluent builder API for creating systems and bundles
- Event handling with lifecycle hooks for systems
- Resource management for global state
- Simplified system API - all system methods receive the ECSpresso instance

### System API Design

All system methods (process, onAttach, onDetach, and event handlers) receive the ECSpresso instance as a parameter, which provides:

- Access to entity management via `ecspresso.entityManager`
- Access to resources via `ecspresso.resourceManager`
- Access to events via `ecspresso.eventBus`

This design simplifies the API and allows systems access to all ECS functionality through a single reference. Benefits of this approach include:

- **Simpler method signatures**: Systems only need to deal with one additional parameter (the ECS instance) rather than multiple managers
- **Future extensibility**: New functionality added to the ECSpresso class is automatically available to all systems without changing method signatures
- **Consistency**: All system methods (process, lifecycle hooks, event handlers) use the same parameter pattern
- **Reduced verbosity**: Systems can be written more concisely while still having access to all ECS functionality

## Installation

```bash
# Add the library to your project
npm install ecspresso
```

## Usage

### Basic Setup

```typescript
import ECSpresso, { Bundle } from 'ecspresso';

// Define your component types
interface Position {
  x: number;
  y: number;
}

interface Velocity {
  dx: number;
  dy: number;
}

// Define your event types
interface CollisionEvent {
  entityA: number;
  entityB: number;
}

// Define your resource types
interface GameState {
  score: number;
  level: number;
}

// Create an ECS instance with your types
const ecspresso = new ECSpresso<
  { position: Position; velocity: Velocity },
  { collision: CollisionEvent },
  { gameState: GameState }
>();

// Add resources
ecspresso.addResource('gameState', { score: 0, level: 1 });

// Create an entity
const entity = ecspresso.entityManager.createEntity();

// Add components to the entity
ecspresso.entityManager.addComponent(entity.id, 'position', { x: 0, y: 0 });
ecspresso.entityManager.addComponent(entity.id, 'velocity', { dx: 1, dy: 2 });

// Run the simulation
ecspresso.update(16.67); // Pass delta time in ms
```

### Creating Systems

Systems should be created through a bundle. You can create a bundle and then add systems to it:

```typescript
// Create a bundle
const gameBundle = new Bundle<
  { position: Position; velocity: Velocity },
  { collision: CollisionEvent },
  { gameState: GameState }
>('gameBundle');

// Create a movement system within the bundle
const movementSystem = gameBundle
  .addSystem('movement')
  .addQuery('movable', {
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Process entities with both position and velocity
    for (const entity of queries.movable) {
      const { position, velocity } = entity.components;
      position.x += velocity.dx * (deltaTime / 1000);
      position.y += velocity.dy * (deltaTime / 1000);
    }
  });

// Install the bundle to add the system to the ECS
ecspresso.install(gameBundle);
```

### Using Bundles

```typescript
// Create a physics bundle
const physicsBundle = new Bundle<
  { position: Position; velocity: Velocity },
  { collision: CollisionEvent },
  {}
>('physics');

// Add a collision system to the bundle
physicsBundle
  .addSystem('collision')
  .addQuery('collidable', {
    with: ['position']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Check for collisions
    // ...
    // Emit collision events
    ecspresso.eventBus.publish('collision', { entityA: 1, entityB: 2 });
  });

// Install the bundle
ecspresso.install(physicsBundle);
```

### Event Handling

```typescript
// Create a bundle for the score system
const gameUIBundle = new Bundle<
  { position: Position; velocity: Velocity },
  { collision: CollisionEvent },
  { gameState: GameState }
>('gameUI');

// Create a system that handles collision events
gameUIBundle
  .addSystem('score')
  .setEventHandlers({
    collision: {
      handler: (event, ecs) => {
        // Handle collision event
        const gameState = ecspresso.resourceManager.getResource('gameState');
        if (gameState) {
          gameState.score += 10;
        }
      }
    }
  });

// Add the system to the ECS
ecspresso.install(gameUIBundle);
```

## Advanced Features

### Merging Bundles

```typescript
import { mergeBundles } from 'ecspresso';

// Merge multiple bundles into one
const gameBundle = mergeBundles(
  'game',
  physicsBundle,
  renderBundle,
  inputBundle
);

// Install the merged bundle
ecspresso.install(gameBundle);
```

### System Lifecycle Hooks

```typescript
// Create a bundle for the rendering systems
const renderBundle = new Bundle<
  { position: Position; sprite: Sprite },
  {},
  { renderer: Renderer }
>('render');

// Create a system with lifecycle hooks
renderBundle
  .addSystem('render')
  .setOnAttach((ecs) => {
    // Initialize rendering resources
    console.log('Render system attached');
    // You could initialize renderer resources here
    ecspresso.addResource('renderer', new Renderer());
  })
  .setOnDetach((ecs) => {
    // Clean up rendering resources
    console.log('Render system detached');
    // You could clean up renderer resources here
    const renderer = ecspresso.getResource('renderer');
    if (renderer) {
      renderer.dispose();
    }
  });

// Install the bundle
ecspresso.install(renderBundle);
```

### Complex System Example

The following example demonstrates a system that uses multiple aspects of the ECS (queries, resources, and events) with the simplified API:

```typescript
// Create an AI bundle
const aiBundle = new Bundle<
  { 
    position: Position; 
    ai: AIComponent; 
    health: Health;
    stunned: StunnedEffect;
    player: PlayerTag;
  },
  { enemySpottedPlayer: EnemySpottedEvent },
  { gameConfig: GameConfig }
>('enemyAI');

// Create a complex AI system that needs access to multiple ECS features
aiBundle
  .addSystem('enemyAI')
  .addQuery('enemies', {
    with: ['position', 'ai', 'health'],
    without: ['stunned']
  })
  .addQuery('players', {
    with: ['position', 'player']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Access game configuration from resources
    const config = ecspresso.resourceManager.get('gameConfig');
    const difficultyMultiplier = config?.difficulty || 1.0;
    
    // Process each enemy
    for (const enemy of queries.enemies) {
      // Find the nearest player
      let nearestPlayer = null;
      let shortestDistance = Infinity;
      
      for (const player of queries.players) {
        const distance = calculateDistance(
          enemy.components.position,
          player.components.position
        );
        
        if (distance < shortestDistance) {
          nearestPlayer = player;
          shortestDistance = distance;
        }
      }
      
      if (nearestPlayer && shortestDistance < enemy.components.ai.detectionRange * difficultyMultiplier) {
        // Enemy detected player, update AI state
        if (enemy.components.ai.state !== 'chasing') {
          enemy.components.ai.state = 'chasing';
          
          // Emit event that enemy spotted player
          ecspresso.eventBus.publish('enemySpottedPlayer', {
            enemyId: enemy.id,
            playerId: nearestPlayer.id
          });
        }
        
        // Move enemy toward player
        moveToward(enemy, nearestPlayer, deltaTime);
      }
    }
  });

// Install the AI bundle
ecspresso.install(aiBundle);
```

This example shows how having access to the entire ECS through a single parameter simplifies the code, as the system can easily work with entity queries, access resources, and publish events without needing separate parameters for each manager.

## Development

To install dependencies:

```bash
bun install
```

To run tests:

```bash
bun test
```

This project was created using `bun init` in bun v1.2.4. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.
