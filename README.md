# ECSpresso

*(pronounced "ex-presso")*

__Note: This is a VERY early work in progress. 0 work on performance has been done while the API is being nailed down. The documention is also being autogenerated while this ECSpresso being iterated on.__

A lightweight, type-safe Entity Component System (ECS) library for TypeScript applications and games.

## Working examples

Run `bun examples` and open `http://localhost:3000` to see usage examples.

## Overview

ECSpresso is a flexible and efficient Entity Component System implementation that provides:

- **Type-safe API**: Fully leverages TypeScript's type system for component, event, and resource definitions
- **Event System**: Built-in pub/sub event system for communication between systems
- **Resource Management**: Global state management through a dedicated resource manager
- **Bundle System**: Modular and reusable collections of components, resources, and systems
- **Query System**: Efficient entity filtering based on component presence/absence
- **Flexible System Creation**: Create systems directly or through bundles

## Core Concepts

### Entity Component System

The ECS pattern separates data (Components) from behavior (Systems) through Entities:

- **Entities**: Unique identifiers that components can be attached to
- **Components**: Plain data objects that hold state but no behavior
- **Systems**: Logic that processes entities with specific components
- **Resources**: Global state shared between systems
- **Events**: Messages passed between systems

### Key Features

- Type-safe queries to filter entities based on component combinations
- Fluent builder API for creating systems directly or through bundles
- Event handling with lifecycle hooks for systems
- Resource management for global state
- Simplified system API - all system methods receive the ECSpresso instance

### System API Design

All system methods (process, onAttach, onDetach, and event handlers) receive the ECSpresso instance as a parameter, which provides:

- Access to entity management via `ecspresso.entityManager`
- Access to resources via `ecspresso.resourceManager`
- Access to events via `ecspresso.eventBus`

This design simplifies the API and allows systems access to all ECS functionality through a single reference. Benefits of this approach include:

- **Simpler method signatures**: Systems only need to deal with one additional parameter (the ECS instance) rather than multiple managers
- **Future extensibility**: New functionality added to the ECSpresso class is automatically available to all systems without changing method signatures
- **Consistency**: All system methods (process, lifecycle hooks, event handlers) use the same parameter pattern
- **Reduced verbosity**: Systems can be written more concisely while still having access to all ECS functionality

## Installation

```bash
# Add the library to your project
npm install ecspresso
```

## Usage

### Basic Setup

```typescript
import ECSpresso, { Bundle } from 'ecspresso';

// Define your component types
interface MyComponents {
  position: { x: number; y: number };
  velocity: { dx: number; dy: number };
  sprite: { url: string; width: number; height: number };
}

// Define your event types
interface MyEvents {
  collision: { entityA: number; entityB: number };
  playerSpawn: { id: number; position: { x: number; y: number } };
}

// Define your resource types
interface MyResources {
  gameState: { score: number; level: number };
  config: { debug: boolean; maxEntities: number };
}

// Create an ECS instance with your types
const world = new ECSpresso<MyComponents, MyEvents, MyResources>();

// Add resources
world.addResource('gameState', { score: 0, level: 1 });
world.addResource('config', { debug: true, maxEntities: 1000 });

// Create an entity
const entity = world.entityManager.createEntity();

// Add components to the entity
world.entityManager.addComponent(entity.id, 'position', { x: 0, y: 0 });
world.entityManager.addComponent(entity.id, 'velocity', { dx: 1, dy: 2 });

// Or add multiple components at once
world.entityManager.addComponents(entity.id, {
  position: { x: 0, y: 0 },
  velocity: { dx: 1, dy: 2 }
});

// Run the simulation
world.update(16.67); // Pass delta time in ms
```

### Creating Systems Directly

ECSpresso allows you to create systems directly on the ECSpresso instance:

```typescript
// Create a movement system directly on the ECSpresso instance
world
  .addSystem('movement')
  .addQuery('movable', {
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Process entities with both position and velocity
    for (const entity of queries.movable) {
      const { position, velocity } = entity.components;
      position.x += velocity.dx * (deltaTime / 1000);
      position.y += velocity.dy * (deltaTime / 1000);
    }
  })
  .build(); // Important: Call build() to finalize the system
```

The `build()` method finalizes the system and registers it with the ECSpresso instance. Any lifecycle hooks like `onAttach` will be called immediately when the system is built.

### System Lifecycle Hooks

You can add lifecycle hooks to systems that will be called when the system is attached or detached:

```typescript
// Create a rendering system with lifecycle hooks
world
  .addSystem('renderer')
  .addQuery('sprites', {
    with: ['position', 'sprite']
  })
  .setOnAttach((ecs) => {
    console.log('Render system attached');
    // Initialize rendering resources
  })
  .setOnDetach((ecs) => {
    console.log('Render system detached');
    // Clean up rendering resources
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Render all sprites at their positions
    for (const entity of queries.sprites) {
      const { position, sprite } = entity.components;
      // Render sprite at position
    }
  })
  .build();
```

### Event Handling

Systems can handle events emitted by other systems:

```typescript
// Create a system that handles collision events
world
  .addSystem('score')
  .setEventHandlers({
    collision: {
      handler: (event, ecs) => {
        // Handle collision event
        const gameState = ecs.getResourceOrThrow('gameState');
        gameState.score += 10;
        
        console.log(`Score: ${gameState.score}`);
      }
    }
  })
  .build();

// Emit an event from another system
world.eventBus.publish('collision', { entityA: entity.id, entityB: 2 });
```

### Using Bundles for System Organization

Bundles allow you to group related systems, resources, and components:

```typescript
// Create a physics bundle
const physicsBundle = new Bundle<MyComponents, MyEvents, MyResources>('physics');

// Add a system to the bundle
const collisionSystem = physicsBundle
  .addSystem('collision')
  .addQuery('collidable', {
    with: ['position']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Check for collisions between entities
    for (const entity of queries.collidable) {
      // Collision detection logic
      // ...
      
      // Emit collision events when detected
      ecs.eventBus.publish('collision', { 
        entityA: entity.id, 
        entityB: otherEntity.id 
      });
    }
  });

// Access the bundle for chaining
physicsBundle
  .addSystem('movement')
  .addQuery('movable', {
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    for (const entity of queries.movable) {
      const { position, velocity } = entity.components;
      position.x += velocity.dx * (deltaTime / 1000);
      position.y += velocity.dy * (deltaTime / 1000);
    }
  })
  .bundle // Access bundle for chaining to add another system
  .addSystem('friction')
  .addQuery('moving', {
    with: ['velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    for (const entity of queries.moving) {
      const { velocity } = entity.components;
      // Apply friction
      velocity.dx *= 0.99;
      velocity.dy *= 0.99;
    }
  });

// Install the bundle to add all systems to the ECSpresso instance
world.install(physicsBundle);

// The install method merges the bundle's type information with the ECSpresso instance
// TypeScript now knows about components, events, and resources from the bundle
world
  .addSystem('newSystem')
  .addQuery('withBundleComponents', {
    // Component types from the bundle are now recognized
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Process entities using components from the bundle
  })
  .build();
```

With bundles, you don't need to call `build()` on the systems. The systems are built when the bundle is installed.

### System Chaining with ECSpresso

When adding systems directly to ECSpresso, you can access the ECSpresso instance for chaining:

```typescript
// Create a system and access the ECSpresso instance for chaining
world
  .addSystem('playerSystem')
  .addQuery('players', {
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Process player entities
  })
  .build()
  .ecspresso // Access the ECSpresso instance after building
  .addSystem('enemySystem')
  .addQuery('enemies', {
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    // Process enemy entities
  })
  .build();
```

### Merging Bundles

For larger applications, you can organize systems into multiple bundles and merge them:

```typescript
import { mergeBundles } from 'ecspresso';

// Create individual feature bundles with their own type definitions
const physicsBundle = new Bundle<{ position: {x: number, y: number}, velocity: {dx: number, dy: number} }, {}, {}>('physics');
const renderBundle = new Bundle<{ sprite: {url: string, width: number, height: number} }, {}, {}>('render');
const aiBundle = new Bundle<{}, { enemySpotted: {entityId: number} }, {}>('ai');

// Add systems to each bundle
// ...

// Merge bundles into a game bundle
// Type information is automatically combined!
const gameBundle = mergeBundles(
  'game',
  physicsBundle,
  renderBundle,
  aiBundle
);

// Install the merged bundle
// The ECSpresso instance now knows about all components, events, and resources
// from all the merged bundles
const typedWorld = world.install(gameBundle);

// TypeScript fully recognizes all the component types from all bundles
typedWorld
  .addSystem('combinedSystem')
  .addQuery('renderableMovingEntities', {
    // Can use components from both physics and render bundles
    with: ['position', 'velocity', 'sprite'],
  })
  .setEventHandlers({
    // Can use events from the AI bundle
    enemySpotted: {
      handler: (event, ecs) => {
        // Handle enemy spotted event
      }
    }
  })
  .build();
```

## Advanced Features

### Removing Systems

You can remove systems by their label:

```typescript
// Remove a system
const removed = world.removeSystem('movement');
console.log(`System removed: ${removed}`); // true if system was found and removed
```

When a system is removed, its `onDetach` lifecycle hook is called if defined.

### Adding Resources through Bundles

Bundles can also contain resources:

```typescript
// Create a bundle with resources
const uiBundle = new Bundle<MyComponents, MyEvents, MyResources>('ui');

// Add resources to the bundle
uiBundle.addResource('uiState', { 
  menuOpen: false, 
  currentScreen: 'main' 
});

// Add systems to the bundle
uiBundle
  .addSystem('uiRenderer')
  // ...

// Install the bundle to add both resources and systems
world.install(uiBundle);
```

## TypeScript Integration

ECSpresso is designed to provide strong type safety. The type parameters for components, events, and resources flow through the entire API, ensuring type correctness at compile time.

```typescript
// Properly typed queries and component access
world
  .addSystem('typeSafeSystem')
  .addQuery('entities', {
    with: ['position', 'velocity']
  })
  .setProcess((queries, deltaTime, ecs) => {
    for (const entity of queries.entities) {
      // TypeScript knows these components exist and their types
      const position = entity.components.position; // { x: number, y: number }
      const velocity = entity.components.velocity; // { dx: number, dy: number }
      
      // This would cause a TypeScript error - sprite not guaranteed to exist
      // const sprite = entity.components.sprite;
    }
  })
  .build();
```

### Type Inference with Bundles

When installing bundles, ECSpresso intelligently merges type information:

```typescript
// Initial ECSpresso with base types
interface BaseComponents {
  health: { current: number, max: number };
}
const world = new ECSpresso<BaseComponents, {}, {}>();

// Bundle with additional component types
interface WeaponComponents {
  weapon: { damage: number, range: number };
}
const weaponsBundle = new Bundle<WeaponComponents, {}, {}>('weapons');

// When installed, the returned ECSpresso instance has combined types
const enhancedWorld = world.install(weaponsBundle);
// Type is now: ECSpresso<BaseComponents & WeaponComponents, {}, {}>

// Full type safety with components from both the base and bundle
enhancedWorld
  .addSystem('combatSystem')
  .addQuery('fighters', {
    // TypeScript recognizes both component types
    with: ['health', 'weapon']
  })
  .setProcess((queries, deltaTime, ecs) => {
    for (const entity of queries.fighters) {
      // Type-safe access to components from both sources
      const health = entity.components.health;   // From BaseComponents
      const weapon = entity.components.weapon;   // From WeaponComponents
      
      // TypeScript provides full intellisense for these combined types
      console.log(`Entity with ${health.current}/${health.max} HP and ${weapon.damage} damage`);
    }
  })
  .build();
```

This deep type integration ensures that the TypeScript compiler can verify the correctness of your code at compile time, minimizing runtime errors.

## Development

To install dependencies:

```bash
bun install
```

To run tests:

```bash
bun test
```

This project was created using `bun init` in bun v1.2.4. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.
